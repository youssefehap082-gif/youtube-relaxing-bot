name: Auto Upload Long Relaxing Videos (4/day)

on:
  schedule:
    - cron: '0 09 * * *'  # 09:00 UTC
    - cron: '0 15 * * *'  # 15:00 UTC
    - cron: '0 21 * * *'  # 21:00 UTC
    - cron: '0 03 * * *'  # 03:00 UTC
  workflow_dispatch:

jobs:
  upload_long:
    runs-on: ubuntu-latest
    timeout-minutes: 120

    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Install tools
        run: |
          sudo apt-get update -y
          sudo apt-get install -y jq curl ffmpeg

      - name: Prepare workspace
        run: |
          rm -rf work clips out final || true
          mkdir -p work clips out final

      - name: Fetch clips from sources (Pexels -> Pixabay -> Coverr)
        env:
          PEXELS_API_KEY: ${{ secrets.PEXELS_API_KEY }}
          PIXABAY_API_KEY: ${{ secrets.PIXABAY_API_KEY }}
          COVERR_API_KEY: ${{ secrets.COVERR_API_KEY }}
        run: |
          set -e
          TOPICS=("relaxing" "rain" "ocean" "forest" "waterfall" "snow" "clouds" "desert" "night")
          QUERY=${TOPICS[$RANDOM % ${#TOPICS[@]}]}
          echo "Query: $QUERY"

          # Try Pexels
          PEX=$(curl -s -H "Authorization: $PEXELS_API_KEY" "https://api.pexels.com/videos/search?query=$QUERY&per_page=15")
          CNT=$(echo "$PEX" | jq '.videos | length')
          urls=()
          if [ "$CNT" -gt 0 ]; then
            for i in $(seq 0 5); do
              IDX=$((RANDOM % CNT))
              URL=$(echo "$PEX" | jq -r ".videos[$IDX].video_files[] | select(.quality==\"hd\") | .link" | head -n1)
              if [ -n "$URL" ] && [ "$URL" != "null" ]; then urls+=("$URL"); fi
            done
          fi

          # If not enough, try Pixabay
          if [ "${#urls[@]}" -lt 4 ] && [ -n "$PIXABAY_API_KEY" ]; then
            PB=$(curl -s "https://pixabay.com/api/videos/?key=$PIXABAY_API_KEY&q=$QUERY&per_page=20")
            CNT2=$(echo "$PB" | jq '.hits | length')
            if [ "$CNT2" -gt 0 ]; then
              for i in $(seq 0 5); do
                IDX=$((RANDOM % CNT2))
                URL=$(echo "$PB" | jq -r ".hits[$IDX].videos.medium.url" | head -n1)
                if [ -n "$URL" ] && [ "$URL" != "null" ]; then urls+=("$URL"); fi
              done
            fi
          fi

          # Fallback Coverr
          if [ "${#urls[@]}" -lt 3 ] && [ -n "$COVERR_API_KEY" ]; then
            CV=$(curl -s -H "Authorization: Bearer $COVERR_API_KEY" "https://api.coverr.co/videos?per_page=20")
            URL=$(echo "$CV" | jq -r '.data[0].assets[0].url' | head -n1)
            if [ -n "$URL" ] && [ "$URL" != "null" ]; then urls+=("$URL"); fi
          fi

          if [ "${#urls[@]}" -eq 0 ]; then
            echo "No clips found from any source." >&2
            exit 1
          fi

          # Download up to 6 distinct clips
          i=0
          for u in "${urls[@]}"; do
            if [ $i -ge 6 ]; then break; fi
            echo "Downloading clip $i : $u"
            curl -L "$u" -o "clips/clip_$i.mp4"
            i=$((i+1))
          done

      - name: Build long video (~8-15 min) and ensure audio
        env:
          PIXABAY_API_KEY: ${{ secrets.PIXABAY_API_KEY }}
          MIXKIT_FALLBACK_AUDIO: ${{ secrets.MIXKIT_FALLBACK_AUDIO }}
        run: |
          set -e
          # Trim each clip to 2 minutes max for variety, create concat list
          rm -f out/list.txt || true
          TOTAL=0
          for f in clips/*.mp4; do
            [ -f "$f" ] || continue
            # create trimmed file for uniform length
            ffmpeg -y -i "$f" -t 120 -c copy "out/trim_${f##*/}"
            duration=$(ffprobe -v error -show_entries format=duration -of csv=p=0 "out/trim_${f##*/}" | cut -d. -f1)
            echo "file '$(pwd)/out/trim_${f##*/}'" >> out/list.txt
            TOTAL=$((TOTAL + duration))
            if [ "$TOTAL" -ge 600 ]; then break; fi
          done

          if [ "$TOTAL" -lt 600 ]; then
            # if short total, loop first clip to reach ~10 minutes
            echo "Total duration $TOTAL sec < 600, looping first clip to extend"
            ffmpeg -y -stream_loop -1 -i out/trim_clip_0.mp4 -t 600 -c copy final/long_combined.mp4
          else
            ffmpeg -y -f concat -safe 0 -i out/list.txt -c copy final/long_combined.mp4
          fi

          # Ensure audio; if missing try to extract audio from a Pixabay clip (prefer)
          if ! ffmpeg -i final/long_combined.mp4 -af "volumedetect" -f null /dev/null 2>&1 | grep -q "mean_volume"; then
            echo "No audio detected in final video -> try get audio from Pixabay video"
            if [ -n "$PIXABAY_API_KEY" ]; then
              PB=$(curl -s "https://pixabay.com/api/videos/?key=$PIXABAY_API_KEY&q=rain&per_page=20")
              PB_COUNT=$(echo "$PB" | jq '.hits | length')
              if [ "$PB_COUNT" -gt 0 ]; then
                IDX=$((RANDOM % PB_COUNT))
                URL=$(echo "$PB" | jq -r ".hits[$IDX].videos.medium.url")
                curl -L "$URL" -o bg_video.mp4 || true
                if [ -f bg_video.mp4 ]; then
                  ffmpeg -y -i bg_video.mp4 -vn -ar 44100 -ac 2 -b:a 128k bg_audio.mp3
                  ffmpeg -y -i final/long_combined.mp4 -i bg_audio.mp3 -shortest -c:v copy -c:a aac -b:a 128k final/long_with_audio.mp4
                  mv final/long_with_audio.mp4 final_video.mp4 || true
                fi
              fi
            fi
          fi

          # If still no audio, use fallback Mixkit link
          if [ ! -f final_video.mp4 ]; then
            FALLBACK="${MIXKIT_FALLBACK_AUDIO:-https://assets.mixkit.co/music/preview/mixkit-relaxing-piano-628.mp3}"
            curl -L -o bg.mp3 "$FALLBACK" || true
            ffmpeg -y -stream_loop -1 -i bg.mp3 -i final/long_combined.mp4 -shortest -c:v copy -c:a aac -b:a 128k final_video.mp4
          fi

          echo "Final long video:"
          ls -lh final_video.mp4
          ffprobe -v error -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 final_video.mp4

      - name: Get YouTube access token
        id: get_token
        env:
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          YT_REFRESH_TOKEN: ${{ secrets.YT_REFRESH_TOKEN }}
        run: |
          set -e
          resp=$(curl -s -d client_id="$GOOGLE_CLIENT_ID" -d client_secret="$GOOGLE_CLIENT_SECRET" -d refresh_token="$YT_REFRESH_TOKEN" -d grant_type=refresh_token https://oauth2.googleapis.com/token)
          ACCESS_TOKEN=$(echo "$resp" | jq -r .access_token)
          if [ -z "$ACCESS_TOKEN" ] || [ "$ACCESS_TOKEN" = "null" ]; then
            echo "Failed to get access token"; echo "$resp"; exit 1
          fi
          echo "access=$ACCESS_TOKEN" >> $GITHUB_OUTPUT

      - name: Create upload session & upload final video
        env:
          ACCESS_TOKEN: ${{ steps.get_token.outputs.access }}
        run: |
          set -e
          TITLE_LIST=("Relaxing Nature Sounds for Sleep" "Soothing Ocean Waves - Calm" "Rain Ambience for Deep Sleep" "Peaceful Forest & Waterfall" "Calm River Flow for Meditation")
          TITLE=${TITLE_LIST[$RANDOM % ${#TITLE_LIST[@]}]}
          DESCRIPTION="Relax and sleep to calming nature sounds and scenery. Auto-uploaded. #relaxing #nature #sleep"
          echo "$TITLE" > title.txt
          jq -n --arg t "$TITLE" --arg d "$DESCRIPTION" '{"snippet":{"title':$t,"description":$d,"tags":["relaxing","nature","sleep","ambient"],"categoryId":"22"},"status":{"privacyStatus":"public"}}' > meta.json || true
          # fallback create meta manually if jq json creation fails
          cat > meta.json <<EOF
{"snippet":{"title":"$TITLE","description":"$DESCRIPTION","tags":["relaxing","nature","sleep","ambient"],"categoryId":"22"},"status":{"privacyStatus":"public"}}
EOF
          curl -s -D headers.txt -o body.txt -X POST "https://www.googleapis.com/upload/youtube/v3/videos?uploadType=resumable&part=snippet,status" \
            -H "Authorization: Bearer $ACCESS_TOKEN" \
            -H "Content-Type: application/json; charset=UTF-8" \
            -d @meta.json

          UPLOAD_URL=$(grep -i '^Location:' headers.txt | awk '{print $2}' | tr -d '\r\n')
          if [ -z "$UPLOAD_URL" ]; then echo "Failed to get upload URL"; cat headers.txt; cat body.txt; exit 1; fi

          echo "Uploading final_video.mp4 ..."
          curl -s -X PUT -T final_video.mp4 -H "Content-Type: application/octet-stream" "$UPLOAD_URL" -o upload_result.json
          cat upload_result.json
